#!/bin/bash

###
#
# * Creates the secrets necessary for secure communication
#    of the syndesis-oauth-proxy
#
###

#
# Finds the calling script location so that it can then find
# the companion share directory relative to its parent directory
#
# Assumes minikube is up n running
# Assumes that normal user has been selected
# Assumes that the syndesis namespace has been selected
#

BASE64="base64 -w0"

pushd . > /dev/null
SCRIPT_PATH="${BASH_SOURCE[0]}"
if ([ -h "${SCRIPT_PATH}" ]); then
  while([ -h "${SCRIPT_PATH}" ]); do cd `dirname "$SCRIPT_PATH"`;
  SCRIPT_PATH=`readlink "${SCRIPT_PATH}"`; done
fi
cd `dirname ${SCRIPT_PATH}` > /dev/null
SCRIPT_PATH=`pwd`;
popd  > /dev/null

#
# Check we have a share directory
#
SHARE_DIR="$SCRIPT_PATH/../share"
if [ ! -d "$SHARE_DIR" ]; then
  echo "ERROR: Cannot find share directory $SHARE_DIR relative to $SCRIPT_DIR"
fi

KUBE_DIR="$SHARE_DIR/kube"
if [ ! -d "$KUBE_DIR" ]; then
  echo "ERROR: Cannot find kube data directory $KUBE_DIR relative to $SHARE_DIR"
fi

if [ -f "$KUBE_DIR/kube-common" ]; then
   . $KUBE_DIR/kube-common
else
  echo "ERROR: Cannot source kube common functions ... exiting"
  exit 1
fi

SYN_DIR="$SHARE_DIR/syndesis"
if [ ! -d "$SYN_DIR" ]; then
  echo "ERROR: Cannot find syndesis data directory $SYN_DIR relative to $SHARE_DIR"
fi

#
# Creates the syndesis credentials secret
#
credsec="kube-oauth-credentials.yml.tmpl"
if [ -f ${SYN_DIR}/${credsec} ]; then

  read -p 'Provider Id, eg. github: ' provider
  if [ -z "${provider}" ]; then
    exit_err "ERROR: provider not specified"
  fi

  read -p 'Client Id (id received from provider): ' client_id
  if [ -z "${client_id}" ]; then
    exit_err "ERROR: client id not specified"
  fi

  read -p 'Client Secret (secret received from provider): ' client_secret
  if [ -z "${client_secret}" ]; then
    exit_err "ERROR: provider not specified"
  fi

  cat ${SYN_DIR}/${credsec} | sed -e "s/<PROVIDER>/${provider}/" -e "s/<CLIENT-ID>/${client_id}/" -e "s/<CLIENT-SECRET>/${client_secret}/" | $KUBECTL apply -f -
else
  echo "WARNING: cannot find ${credsec}"
fi

#
# Create the syndesis comms secret
#
commsec="kube-oauth-comms.yml.tmpl"
if [ -f ${SYN_DIR}/${commsec} ]; then

  # Generate the signed certificate
  read -p 'Host name for external access to syndesis, eg. syndesis.dash: ' external_host
  if [ -z "${external_host}" ]; then
    exit_err "ERROR: host not specified"
  fi

  OAUTH_DIR="${SYN_DIR}/oauth-certificate"

  #
  # Call the create signed certificate script
  #
  pushd ${OAUTH_DIR} >/dev/null
  ${OAUTH_DIR}/create-signed-oauth-proxy-cert -h ${external_host} > /dev/null
  popd >/dev/null

  if [ ! -d ${OAUTH_DIR}/${external_host} ]; then
    exit_err "ERROR: Failed to create certificate"
  fi

  # Extract the certificate and key encoded as base64
  oauth_cert=$(cat ${OAUTH_DIR}/${external_host}/certs/${external_host}.cert.pem | ${BASE64})
  oauth_key=$(cat ${OAUTH_DIR}/${external_host}/private/${external_host}.key.pem | ${BASE64})

  cat ${SYN_DIR}/${commsec} | sed -e "s/<TLS-CERT>/${oauth_cert}/" -e "s/<TLS-KEY>/${oauth_key}/" | $KUBECTL apply -f -

  #
  # Ensure the hostname is inserted in the Custom Resource
  #
  cr="kube-cr.yml"
  crtmpl="${cr}.tmpl"
  CR_DIR="${SHARE_DIR}/../cr"

  mkdir -p "${CR_DIR}"
  cat ${SYN_DIR}/${crtmpl} | sed -e "s/<EXTERNAL_HOSTNAME>/${external_host}/" > "${CR_DIR}/${cr}"
  if [ ! -f "${CR_DIR}/${cr}" ]; then
    exit_err "ERROR: Failed to create custom resource"
  else
    echo
    echo "*************************************"
    echo "*"
    echo "* The syndesis custom resource has been created at ${CR_DIR}/${cr}"
    echo "*"
    echo "*************************************"
  fi

else
  echo "WARNING: cannot find ${commsec}"
fi

